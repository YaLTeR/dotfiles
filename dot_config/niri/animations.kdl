animations {
    // off
    // slowdown 100
    // slowdown 10
    // slowdown 4
    // slowdown 3
    // slowdown 2
    // slowdown 1.5
    slowdown 1.2

    workspace-switch {
        // off
        // duration-ms 1000
        // curve "linear"
        // curve "ease-out-cubic"
        // curve "cubic-bezier" 0 1.5 0.5 1
        // spring damping-ratio=1.0 stiffness=1000 epsilon=0.0001
    }

    overview-open-close {
        // spring damping-ratio=1.0 stiffness=400 epsilon=0.0001
        // spring damping-ratio=1.0 stiffness=800 epsilon=0.0001
        // spring damping-ratio=1.0 stiffness=1000 epsilon=0.0001
        // spring damping-ratio=6.0 stiffness=1200 epsilon=0.0001
        // curve "linear"
        // duration-ms 50
    }

    window-open {
        // off
        // duration-ms 2500
        // curve "ease-out-expo"
        // spring damping-ratio=0.8 stiffness=1000 epsilon=0.0001
        // duration-ms 1000
        // curve "linear"

        /-custom-shader r"
            vec4 open_color(vec3 coords_geo, vec3 size_geo) {
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                vec2 size = size_geo.xy;
                vec2 coords = (coords_geo.xy - vec2(0.5, 0.5)) * size * 2.0;

                // Some padding for borders and shadows.
                float pad = 8.0;
                coords = coords + vec2(pad, pad);
                size = size + vec2(pad, pad) * 2.0;

                coords = coords / length(size);
                float p = niri_clamped_progress;
                if (p * p <= dot(coords, coords))
                    color = vec4(0.0);

                return color;
            }
        "

        /-custom-shader r"
            vec4 open_color(vec3 coords_geo, vec3 size_geo) {
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                return color;
            }
        "
    }

    /-window-close {
        // off
        // duration-ms 2500
        // duration-ms 1000
        duration-ms 250
        curve "linear"
        // spring damping-ratio=0.8 stiffness=1000 epsilon=0.0001

        custom-shader r"
            mat2 rotate(float angle) {
                return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
            }

            vec4 close_color(vec3 coords_geo, vec3 size_geo) {
                float progress = niri_clamped_progress * niri_clamped_progress;

                vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;

                coords.y -= progress * 200.0;

                float random = (niri_random_seed - 0.5) / 2.0;
                random = sign(random) - random;
                float max_angle = 0.05 * random;

                float angle = progress * max_angle;
                coords = rotate(angle) * coords;

                coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);

                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                return color * (1.0 - niri_clamped_progress);
            }
        "

        /-custom-shader r"
            vec4 close_color(vec3 coords_geo, vec3 size_geo) {
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                return color;
            }
        "
    }

    horizontal-view-movement {
        // off
        // duration-ms 500
        // curve "ease-out-cubic"
        // spring damping-ratio=1.0 stiffness=20 epsilon=0.00001
        // spring damping-ratio=10.0 stiffness=800 epsilon=0.0001
    }

    window-movement {
        // off
        // duration-ms 750
        // curve "ease-out-cubic"
        // spring damping-ratio=1.0 stiffness=20 epsilon=0.00001
        // spring damping-ratio=0.2 stiffness=800 epsilon=0.0001
    }

    window-resize {
        // off
        // duration-ms 500
        // duration-ms 2500
        // curve "ease-out-cubic"
        // spring damping-ratio=0.2 stiffness=800 epsilon=0.0001

        /-custom-shader r"
            vec4 resize_color(vec3 coords_curr_geo, vec3 size_curr_geo) {
                vec3 coords_next_geo = niri_curr_geo_to_next_geo * coords_curr_geo;
                vec3 coords_prev_geo = niri_curr_geo_to_prev_geo * coords_curr_geo;

                vec3 coords_crop = niri_geo_to_tex_next * coords_next_geo;
                vec3 coords_stretch = niri_geo_to_tex_next * coords_curr_geo;
                vec3 coords_stretch_prev = niri_geo_to_tex_prev * coords_curr_geo;

                // We can crop if the current window size is smaller than the next window
                // size. One way to tell is by comparing to 1.0 the X and Y scaling
                // coefficients in the current-to-next transformation matrix.
                bool can_crop_by_x = niri_curr_geo_to_next_geo[0][0] <= 1.0;
                bool can_crop_by_y = niri_curr_geo_to_next_geo[1][1] <= 1.0;
                bool crop = can_crop_by_x && can_crop_by_y;

                vec4 color;

                if (crop) {
                    // However, when we crop, we also want to crop out anything outside the
                    // current geometry. This is because the area of the shader is unspecified
                    // and usually bigger than the current geometry, so if we don't fill pixels
                    // outside with transparency, the texture will leak out.
                    //
                    // When stretching, this is not an issue because the area outside will
                    // correspond to client-side decoration shadows, which are already supposed
                    // to be outside.
                    if (coords_curr_geo.x < 0.0 || 1.0 < coords_curr_geo.x ||
                            coords_curr_geo.y < 0.0 || 1.0 < coords_curr_geo.y) {
                        color = vec4(0.0);
                    } else {
                        color = texture2D(niri_tex_next, coords_crop.st);
                        // color = texture2D(niri_tex_prev, (niri_geo_to_tex_prev * coords_prev_geo).st);
                    }
                } else {
                    // If we can't crop, then crossfade.
                    color = texture2D(niri_tex_next, coords_stretch.st);
                    vec4 color_prev = texture2D(niri_tex_prev, coords_stretch_prev.st);
                    color = mix(color_prev, color, niri_clamped_progress);
                }

                return color;
            }
        "
    }

    config-notification-open-close {
        // off
        // duration-ms 250
        // curve "ease-out-cubic"
        // spring damping-ratio=0.1 stiffness=1000 epsilon=0.001
    }

    /-exit-confirmation-open-close {
        // off
        // duration-ms 250
        // curve "ease-out-cubic"
        // spring damping-ratio=0.1 stiffness=1000 epsilon=0.001
        // spring damping-ratio=0.6 stiffness=500 epsilon=0.01
    }

    /-screenshot-ui-open {
        // off
        // duration-ms 200
        // curve "ease-out-quad"
    }
}
